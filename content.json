{"meta":{"title":"This is my Blog","subtitle":"","description":"","author":"Kwon Jung Min","url":"https://KJM94.github.io","root":"/"},"pages":[],"posts":[{"title":"Pandas10min","slug":"Pandas10min","date":"2021-04-07T14:07:07.000Z","updated":"2021-04-07T14:14:14.135Z","comments":true,"path":"2021/04/07/Pandas10min/","link":"","permalink":"https://kjm94.github.io/2021/04/07/Pandas10min/","excerpt":"","text":"Pandas new usersimport12import numpy as npimport pandas as pd 객체 생성123s = pd.Series([1,3,5,np.nan,6,8])s 0 1.0 1 3.0 2 5.0 3 NaN 4 6.0 5 8.0 dtype: float64 DataFrameDatetime 인덱스와 레이블이 지정된 열이 있는 Numpy 배열을 전달하여 생성 123dates = pd.date_range(&quot;20130101&quot;, periods=6)dates DatetimeIndex([&#39;2013-01-01&#39;, &#39;2013-01-02&#39;, &#39;2013-01-03&#39;, &#39;2013-01-04&#39;, &#39;2013-01-05&#39;, &#39;2013-01-06&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;) 123df = pd.DataFrame(np.random.randn(6,4),index=dates, columns=list(&quot;ABCD&quot;))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-01 -1.338161 0.110530 0.536230 2.030842 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 2013-01-03 -0.319073 -1.183950 0.094337 0.616546 2013-01-04 0.350805 1.549371 1.245585 -0.153351 2013-01-05 -0.515572 -2.377644 -0.042456 0.071252 2013-01-06 -0.260635 -1.106064 -1.276920 1.408237 DataFrame 시리즈와 같은 변환을 할 수 있는 개체의 DICT를 전달하여 만들기. 123456789101112df2 = pd.DataFrame( &#123; &quot;A&quot; : 1.0, &quot;B&quot; : pd.Timestamp(&quot;20130102&quot;), &quot;C&quot; : pd.Series(1, index=list(range(4)), dtype=&quot;float32&quot;), &quot;D&quot; : np.array([3] * 4, dtype=&quot;int32&quot;), &quot;E&quot; : pd.Categorical([&quot;test&quot;,&quot;train&quot;,&quot;test&quot;,&quot;train&quot;]), &quot;F&quot; : &quot;foo&quot; &#125;)df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D E F 0 1.0 2013-01-02 1.0 3 test foo 1 1.0 2013-01-02 1.0 3 train foo 2 1.0 2013-01-02 1.0 3 test foo 3 1.0 2013-01-02 1.0 3 train foo 그 결과 열 DataFrame은 다른 dtypes를 갖습니다. 1df2.dtypes A float64 B float64 dtype: object 데이터 보기프레임의 상단 및 하단 행을 보는 방법 1df.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-01 -1.338161 0.110530 0.536230 2.030842 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 2013-01-03 -0.319073 -1.183950 0.094337 0.616546 2013-01-04 0.350805 1.549371 1.245585 -0.153351 2013-01-05 -0.515572 -2.377644 -0.042456 0.071252 1df.tail(3) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-04 0.350805 1.549371 1.245585 -0.153351 2013-01-05 -0.515572 -2.377644 -0.042456 0.071252 2013-01-06 -0.260635 -1.106064 -1.276920 1.408237 색인, 열 표시 1df.index DatetimeIndex([&#39;2013-01-01&#39;, &#39;2013-01-02&#39;, &#39;2013-01-03&#39;, &#39;2013-01-04&#39;, &#39;2013-01-05&#39;, &#39;2013-01-06&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;) 1df.columns Index([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], dtype=&#39;object&#39;) DataFrame.to_numpy()기본 데이터의 Numpy 표현을 제공합니다. DataFrame pandas와 Numpy의 근본적인 차이로 인해 데이터 유형이 다른 열이 있는 경우 이 작업은 비용이 많이들 수 있습니다.Numpy 배열에는 전체 배열에 대해 하나의 dtype이 있는 반면 pandas DataFrames에는 열당 하나의 dtype이 있습니다. DataFrame.to_numpy()를 호출하면 pandas는 DataFrame의 모든 dtype을 보유할 수 있는 Numpy dtype을 찾습니다. 결국 object 모든 값을 python 객체로 캐스팅해야 하는식으로 끝날 수 있습니다. df에 대한, DataFrame 모든 부동 소수점 값, DataFrame.to_numpy() 빠르고 및 복사 데이터를 필요로 하지 않는다. 1df.to_numpy() array([[-1.33816087, 0.11053004, 0.53623007, 2.03084207], [ 0.35760296, -0.35574745, 0.0544108 , -0.10210902], [-0.31907276, -1.18395015, 0.09433678, 0.61654553], [ 0.35080472, 1.54937131, 1.24558483, -0.15335078], [-0.51557247, -2.37764397, -0.04245553, 0.07125205], [-0.26063518, -1.10606377, -1.27691993, 1.40823689]]) df2는 DataFrame 여러 dtype으로, DataFrame.to_numpy() 상대적으로 비싸다. 1df2.to_numpy() array([[-0.37591379, 0.80689645], [ 2.71741139, -1.18659735], [ 0.34445035, 0.15736656], [ 0.21151164, 0.70306021]]) DataFrame.to_numpy()출력에 색인 또는 열 레이블을 포함 하지 않습니다. describe() 데이터에 대한 빠른 통계 요약을 보여줍니다. 1df.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D count 6.000000 6.000000 6.000000 6.000000 mean -0.287506 -0.560584 0.101865 0.645236 std 0.629478 1.336571 0.827158 0.897621 min -1.338161 -2.377644 -1.276920 -0.153351 25% -0.466448 -1.164479 -0.018239 -0.058769 50% -0.289854 -0.730906 0.074374 0.343899 75% 0.197945 -0.006039 0.425757 1.210314 max 0.357603 1.549371 1.245585 2.030842 데이터 전치 : 1df.T .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; 2013-01-01 2013-01-02 2013-01-03 2013-01-04 2013-01-05 2013-01-06 A -1.338161 0.357603 -0.319073 0.350805 -0.515572 -0.260635 B 0.110530 -0.355747 -1.183950 1.549371 -2.377644 -1.106064 C 0.536230 0.054411 0.094337 1.245585 -0.042456 -1.276920 D 2.030842 -0.102109 0.616546 -0.153351 0.071252 1.408237 축으로 정렬 : 1df.sort_index(axis=1, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; D C B A 2013-01-01 2.030842 0.536230 0.110530 -1.338161 2013-01-02 -0.102109 0.054411 -0.355747 0.357603 2013-01-03 0.616546 0.094337 -1.183950 -0.319073 2013-01-04 -0.153351 1.245585 1.549371 0.350805 2013-01-05 0.071252 -0.042456 -2.377644 -0.515572 2013-01-06 1.408237 -1.276920 -1.106064 -0.260635 값으로 정렬 : 1df.sort_values(by=&quot;B&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-05 -0.515572 -2.377644 -0.042456 0.071252 2013-01-03 -0.319073 -1.183950 0.094337 0.616546 2013-01-06 -0.260635 -1.106064 -1.276920 1.408237 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 2013-01-01 -1.338161 0.110530 0.536230 2.030842 2013-01-04 0.350805 1.549371 1.245585 -0.153351 선택 선택 및 설정을 위한 표준 python / Numpy 표현식은 직관적이고 대화형 작업에 유용하지만 프로덕션 코드의 경우 최적화 된 pandas 데이터 액세스 방법 .at인 .iat, .loc및 .lioc. 얻기단일 열을 선택하면 다음 Series와 같은 결과가 생성됩니다. 1df[&quot;A&quot;] 2013-01-01 -1.338161 2013-01-02 0.357603 2013-01-03 -0.319073 2013-01-04 0.350805 2013-01-05 -0.515572 2013-01-06 -0.260635 Freq: D, Name: A, dtype: float64 []행을 분할하는 via를 선택합니다. 1df[0:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-01 -1.338161 0.110530 0.536230 2.030842 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 2013-01-03 -0.319073 -1.183950 0.094337 0.616546 1df[&quot;20130102&quot;:&quot;20130104&quot;] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 2013-01-03 -0.319073 -1.183950 0.094337 0.616546 2013-01-04 0.350805 1.549371 1.245585 -0.153351 라벨로 선택레이블을 사용하여 횡단면을 얻으려면 : 1df.loc[dates[0]] A -1.338161 B 0.110530 C 0.536230 D 2.030842 Name: 2013-01-01 00:00:00, dtype: float64 라벨로 다축 선택 : 1df.loc[:,[&quot;A&quot;,&quot;B&quot;]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B 2013-01-01 -1.338161 0.110530 2013-01-02 0.357603 -0.355747 2013-01-03 -0.319073 -1.183950 2013-01-04 0.350805 1.549371 2013-01-05 -0.515572 -2.377644 2013-01-06 -0.260635 -1.106064 레이블 슬라이싱을 표시하며 두 엔드 포인트가 모두 포함됩니다. 1df.loc[&quot;20130102&quot;:&quot;20130104&quot;,[&quot;A&quot;,&quot;B&quot;]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B 2013-01-02 0.357603 -0.355747 2013-01-03 -0.319073 -1.183950 2013-01-04 0.350805 1.549371 반환 된 객체의 크기 감소 : 1df.loc[&quot;20130102&quot;,[&quot;A&quot;,&quot;B&quot;]] A 0.357603 B -0.355747 Name: 2013-01-02 00:00:00, dtype: float64 스칼라 값을 얻으려면 : 1df.loc[dates[0], &quot;A&quot;] -1.3381608728638592 스칼라에 빠르게 액세스하려면 : 1df.at[dates[0], &quot;A&quot;] -1.3381608728638592 위치 별 선택전달 된 정수의 위치를 통해 선택 : 1df.iloc[3] A 0.350805 B 1.549371 C 1.245585 D -0.153351 Name: 2013-01-04 00:00:00, dtype: float64 정수 조각으로 numpy / python과 유사하게 작동합니다. 1df.iloc[3:5, 0:2] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B 2013-01-04 0.350805 1.549371 2013-01-05 -0.515572 -2.377644 Numpy / python 스타일과 유사한 정수 위치 목록 : 1df.iloc[[1,2,4],[0,2]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A C 2013-01-02 0.357603 0.054411 2013-01-03 -0.319073 0.094337 2013-01-05 -0.515572 -0.042456 행을 명시적으로 분할하려면 : 1df.iloc[1:3,:] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 2013-01-03 -0.319073 -1.183950 0.094337 0.616546 열을 명시적으로 분할하려면 다음을 수행하십시오. 1df.iloc[:,1:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; B C 2013-01-01 0.110530 0.536230 2013-01-02 -0.355747 0.054411 2013-01-03 -1.183950 0.094337 2013-01-04 1.549371 1.245585 2013-01-05 -2.377644 -0.042456 2013-01-06 -1.106064 -1.276920 명시적으로 값을 얻으려면 : 1df.iloc[1,1] -0.3557474474984722 스칼라에 빠르게 액세스하려면 : 1df.iat[1,1] -0.3557474474984722 불 인덱싱단일 열의 값을 사용하여 데이터를 선택합니다. 1df[df[&quot;A&quot;]&gt;0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 2013-01-04 0.350805 1.549371 1.245585 -0.153351 불 조건이 충족되는 DataFrame에서 값 선택 1df[df &gt; 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2013-01-01 NaN 0.110530 0.536230 2.030842 2013-01-02 0.357603 NaN 0.054411 NaN 2013-01-03 NaN NaN 0.094337 0.616546 2013-01-04 0.350805 1.549371 1.245585 NaN 2013-01-05 NaN NaN NaN 0.071252 2013-01-06 NaN NaN NaN 1.408237 isin()필터링 방법 사용 : 12345df2 = df.copy()df2[&quot;E&quot;] = [&quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;three&quot;]df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D E 2013-01-01 -1.338161 0.110530 0.536230 2.030842 one 2013-01-02 0.357603 -0.355747 0.054411 -0.102109 one 2013-01-03 -0.319073 -1.183950 0.094337 0.616546 two 2013-01-04 0.350805 1.549371 1.245585 -0.153351 three 2013-01-05 -0.515572 -2.377644 -0.042456 0.071252 four 2013-01-06 -0.260635 -1.106064 -1.276920 1.408237 three 설정새 열을 설정하면 인덱스별로 데이터가 자동으로 정렬됩니다. 12345s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range(&quot;20130102&quot;, periods=6))s1df[&quot;F&quot;] = s1 라벨 별 설정 값: 1df.at[dates[0], &quot;A&quot;] = 0 위치 별 설정 값 : 1df.iat[0,1]=0 Numpy 배열로 할당하여 설정: 1df.loc[:, &quot;D&quot;] = np.array([5] * len(df)) 이전 설정 작업의 결과 : 1df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D F 2013-01-01 0.000000 0.000000 0.536230 5 NaN 2013-01-02 0.357603 -0.355747 0.054411 5 1.0 2013-01-03 -0.319073 -1.183950 0.094337 5 2.0 2013-01-04 0.350805 1.549371 1.245585 5 3.0 2013-01-05 -0.515572 -2.377644 -0.042456 5 4.0 2013-01-06 -0.260635 -1.106064 -1.276920 5 5.0 where 설정이 있는 작업 12345df2 = df.copy()df2[df2 &gt; 0] = -df2df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D F 2013-01-01 0.000000 0.000000 -0.536230 -5 NaN 2013-01-02 -0.357603 -0.355747 -0.054411 -5 -1.0 2013-01-03 -0.319073 -1.183950 -0.094337 -5 -2.0 2013-01-04 -0.350805 -1.549371 -1.245585 -5 -3.0 2013-01-05 -0.515572 -2.377644 -0.042456 -5 -4.0 2013-01-06 -0.260635 -1.106064 -1.276920 -5 -5.0 누락 된 데이터pandas는 주로 값 np.nan을 사용하여 누락 된 데이터를 나타냅니다. 기본적으로 계산에 포함되지 않습니다. 재 인덱싱을 사용하면 지정된 축에서 인덱스를 변경/ 추가/ 삭제할 수 있습니다. 이것은 데이터의 복사본을 반환합니다. 12345df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + [&quot;E&quot;])df1.loc[dates[0] : dates[1], &quot;E&quot;] = 1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D F E 2013-01-01 0.000000 0.000000 0.536230 5 NaN 1.0 2013-01-02 0.357603 -0.355747 0.054411 5 1.0 1.0 2013-01-03 -0.319073 -1.183950 0.094337 5 2.0 NaN 2013-01-04 0.350805 1.549371 1.245585 5 3.0 NaN 누락 된 데이터가 있는 행을 삭제합니다. 1df1.dropna(how=&quot;any&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D F E 2013-01-02 0.357603 -0.355747 0.054411 5 1.0 1.0 누락 된 데이터 채우기. 1df1.fillna(value=5) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D F E 2013-01-01 0.000000 0.000000 0.536230 5 5.0 1.0 2013-01-02 0.357603 -0.355747 0.054411 5 1.0 1.0 2013-01-03 -0.319073 -1.183950 0.094337 5 2.0 5.0 2013-01-04 0.350805 1.549371 1.245585 5 3.0 5.0 값이 불 인 마스크를 가져옵니다. nan 1pd.isna(df1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D F E 2013-01-01 False False False False True False 2013-01-02 False False False False False False 2013-01-03 False False False False False True 2013-01-04 False False False False False True 통계일반적으로 연산은 누락 된 데이터를 제외합니다. 기술 통계 수행 : 1df.mean() A -0.064479 B -0.579006 C 0.101865 D 5.000000 F 3.000000 dtype: float64 다른 축에서 동일한 작업 : 1df.mean(1) 2013-01-01 1.384058 2013-01-02 1.211253 2013-01-03 1.118263 2013-01-04 2.229152 2013-01-05 1.212866 2013-01-06 1.471276 Freq: D, dtype: float64 차원이 다르고 정렬이 필요한 개체로 작동합니다. 또한 Pandas는 지정된 차원을 따라 자동으로 발송됩니다. 12345s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)sdf.sub(s, axis=&quot;index&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D F 2013-01-01 NaN NaN NaN NaN NaN 2013-01-02 NaN NaN NaN NaN NaN 2013-01-03 -1.319073 -2.183950 -0.905663 4.0 1.0 2013-01-04 -2.649195 -1.450629 -1.754415 2.0 0.0 2013-01-05 -5.515572 -7.377644 -5.042456 0.0 -1.0 2013-01-06 NaN NaN NaN NaN NaN 데이터에 함수 적용 : 123df.apply(np.cumsum)df.apply(lambda x: x.max() - x.min()) A 0.873175 B 3.927015 C 2.522505 D 0.000000 F 4.000000 dtype: float64 히스토그램12345s = pd.Series(np.random.randint(0,7,size=10))ss.value_counts() 6 3 0 3 5 2 3 1 1 1 dtype: int64 문자열 메소드시리즈에는 str 아래 코드 스 니펫에서와 같이 배열의 각 요소에서 쉽게 조작할 수 있도록 속성에 문자열 처리 메소드 세트가 있습니다. 패턴일치는 str일반적으로 기본적으로 정규식을 사용하며 경우에 따라 항상 정규식을 사용합니다. 123s = pd.Series([&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;Aaba&quot;,&quot;Baca&quot;, np.nan, &quot;CABA&quot;, &quot;dog&quot;, &quot;cat&quot;])s.str.lower() 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object 병합ConcatPandas는 Series 및 DataFrame 객체를 결합 / 병합 유형 작업의 경우 인덱스 및 관계형 대수 기능에 대한 다양한 종류의 세트 로직과 함께 쉽게 결합 할 수 있는 다양한 기능을 제공합니다. pandas 객체를 다음과 함께 연결 concat(): 123456789df = pd.DataFrame(np.random.randn(10, 4))df# break it into piecespieces = [df[:3],df[3:7],df[7:]]pd.concat(pieces) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; 0 1 2 3 0 -1.192838 0.384087 0.887058 -1.348107 1 1.335282 -0.076665 0.227045 -0.612258 2 -0.483729 1.188195 -0.448694 -2.713682 3 -0.579994 -0.640704 -1.267504 -0.006364 4 1.413399 1.118911 -0.301100 0.044948 5 0.785531 -1.443541 -1.211024 -0.372210 6 0.006017 -1.521360 0.165257 0.633229 7 -0.633135 0.657720 0.524750 -1.968084 8 0.400773 -1.014635 2.229316 -1.433340 9 0.820736 -0.556207 -0.448710 1.945929 a에 열을 추가하는 DataFrame것은 비교적 빠릅니다. 그러나 행을 추가하려면 복사본이 필요하며 비용이 많이들 수 있습니다. 반복적으로 레코드를 추가하여 DataFrame을 빌드하는 대신 미리 빌드 된 레코드 목록을 생성자에 전달하는 것이 좋습니다. 가입SQL스타일이 병합됩니다. 12345678left = pd.DataFrame(&#123;&quot;key&quot;:[&quot;foo&quot;,&quot;foo&quot;],&quot;lval&quot;:[1,2]&#125;)right = pd.DataFrame(&#123;&quot;key&quot;:[&quot;foo&quot;,&quot;foo&quot;],&quot;rval&quot;:[4,5]&#125;)leftrightpd.merge(left, right, on=&quot;key&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; key lval rval 0 foo 1 4 1 foo 1 5 2 foo 2 4 3 foo 2 5 주어질 수 있는 또 다른 예는 다음과 같습니다. 12345678left = pd.DataFrame(&#123;&quot;key&quot; : [&quot;foo&quot;,&quot;bar&quot;], &quot;lval&quot; : [1,2]&#125;)right = pd.DataFrame(&#123;&quot;key&quot; : [&quot;foo&quot;,&quot;bar&quot;], &quot;lval&quot; : [4,5]&#125;)leftrightpd.merge(left, right, on=&quot;key&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; key lval_x lval_y 0 foo 1 4 1 bar 2 5 그룹화“그룹 별”은 다음 단계 중 하나 이상을 포함하는 프로세스를 의미합니다. 일부 기준에 따라 데이터를 그룹으로 분할 각 그룹에 독립적으로 기능 적용 결과를 데이터 구조로 결합 12345678df = pd.DataFrame(&#123; &quot;A&quot; : [&quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;, &quot;foo&quot;], &quot;B&quot; : [&quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;two&quot;, &quot;two&quot;, &quot;one&quot;, &quot;three&quot;], &quot;C&quot; : np.random.randn(8), &quot;D&quot; : np.random.randn(8)&#125;)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 0 foo one -0.714119 0.465098 1 bar one -1.100206 -0.224802 2 foo two -0.919036 -0.011397 3 bar three -0.383577 1.100142 4 foo two 1.012185 -0.492502 5 bar two 0.757571 0.043945 6 foo one 1.298525 1.664578 7 foo three -1.763909 -0.642626 그룹화 한 다음 sum() 결과 그룹에 함수를 적용합니다. 1df.groupby(&quot;A&quot;).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; C D A bar -0.726212 0.919285 foo -1.086354 0.983151 여러 열로 그룹화하면 계층 적 색인이 형성되며 다시 sum()함수를 적용할 수 있습니다. 1df.groupby([&quot;A&quot;, &quot;B&quot;]).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; C D A B bar one -1.100206 -0.224802 three -0.383577 1.100142 two 0.757571 0.043945 foo one 0.584406 2.129676 three -1.763909 -0.642626 two 0.093150 -0.503899 재구성스택12345678910111213141516tuples = list( zip( *[ [&quot;bar&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;qux&quot;, &quot;qux&quot;], [&quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;two&quot;, &quot;one&quot;, &quot;two&quot;], ] ))index = pd.MultiIndex.from_tuples(tuples, names=[&quot;first&quot;,&quot;second&quot;])df = pd.DataFrame(np.random.randn(8,2), index=index, columns=[&quot;A&quot;, &quot;B&quot;])df2 = df[:4]df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B first second bar one -1.662320 0.032596 two -2.130549 -0.498520 baz one -1.052036 -0.809309 two -0.611723 -0.269502 이 stack()메소드는 DataFrame의 열에서 수준을 “압축”합니다. 123stacked = df2.stack()stacked first second bar one A -1.662320 B 0.032596 two A -2.130549 B -0.498520 baz one A -1.052036 B -0.809309 two A -0.611723 B -0.269502 dtype: float64 는 “누적”DataFrame 또는 직렬 (a 갖는 MultiIndex은 AS를 index중), 역 동작 stack()이다 unstack()기본적 unstacks, 최종 레벨 : 12345stacked.unstack()stacked.unstack(1)stacked.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; first bar baz second one A -1.662320 -1.052036 B 0.032596 -0.809309 two A -2.130549 -0.611723 B -0.498520 -0.269502 피벗 테이블123456789df = pd.DataFrame(&#123; &quot;A&quot;: [&quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;] * 3, &quot;B&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] * 4, &quot;C&quot;: [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;] * 2, &quot;D&quot;: np.random.randn(12), &quot;E&quot;: np.random.randn(12)&#125;)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D E 0 one A foo 1.306726 -1.615560 1 one B foo -0.017440 -0.390718 2 two C foo -0.020291 -0.710189 3 three A bar -0.752024 -0.598660 4 one B bar -1.524553 -0.916927 5 one C bar 0.206644 0.784663 6 two A foo 1.864018 -0.087309 7 three B foo -1.175187 0.724690 8 one C foo 0.006408 0.313060 9 one A bar -0.174987 0.181471 10 two B bar 1.864114 0.835734 11 three C bar -0.788907 -0.686647 이 데이터에서 매우 쉽게 피벗 테이블을 생성할 수 있습니다. 1pd.pivot_table(df, values=&quot;D&quot;, index=[&quot;A&quot;, &quot;B&quot;], columns=[&quot;C&quot;]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; C bar foo A B one A -0.174987 1.306726 B -1.524553 -0.017440 C 0.206644 0.006408 three A -0.752024 NaN B NaN -1.175187 C -0.788907 NaN two A NaN 1.864018 B 1.864114 NaN C NaN -0.020291 시계열Pandas는 주파수 변환(예 : 2차 데이터를 5분 데이터로 변환) 중에 리샘플링 작업을 수행하기 위한 간단하고 강력하며 효율적인 기능을 제공합니다. 이는 금융 애플리케이션에서 매우 일반적이지만 이에 국한되지는 않습니다. 12345rng = pd.date_range(&quot;1/1/2012&quot;, periods=100, freq=&quot;S&quot;)ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)ts.resample(&quot;5Min&quot;).sum() 2012-01-01 24059 Freq: 5T, dtype: int64 시간대 표현 : 123456789rng = pd.date_range(&quot;3/6/2012 00:00&quot;, periods=5, freq=&quot;D&quot;)ts = pd.Series(np.random.randn(len(rng)), rng)tsts_utc = ts.tz_localize(&quot;UTC&quot;)ts_utc 2012-03-06 00:00:00+00:00 0.244296 2012-03-07 00:00:00+00:00 -0.722339 2012-03-08 00:00:00+00:00 0.509596 2012-03-09 00:00:00+00:00 -0.530605 2012-03-10 00:00:00+00:00 -0.810000 Freq: D, dtype: float64 다른 시간대로 변환 : 1ts_utc.tz_convert(&quot;US/Eastern&quot;) 2012-03-05 19:00:00-05:00 0.244296 2012-03-06 19:00:00-05:00 -0.722339 2012-03-07 19:00:00-05:00 0.509596 2012-03-08 19:00:00-05:00 -0.530605 2012-03-09 19:00:00-05:00 -0.810000 Freq: D, dtype: float64 시간 범위 표현 간 변환 : 1234567891011rng = pd.date_range(&quot;1/1/2012&quot;, periods=5, freq=&quot;M&quot;)ts = pd.Series(np.random.randn(len(rng)), index=rng)tsps = ts.to_period()psps.to_timestamp() 2012-01-01 0.696409 2012-02-01 -0.801259 2012-03-01 0.236351 2012-04-01 0.249498 2012-05-01 -0.781067 Freq: MS, dtype: float64 기간과 타임 스탬프 사이를 변환하면 편리한 산술 함수를 사용할 수 있습니다. 다음 예에서는 연도가 11월로 끝나는 분기 별 빈도를 분기 종료 다음 달의 오전 9시로 변환합니다. 1234567prng = pd.period_range(&quot;1990Q1&quot;, &quot;2000Q4&quot;, freq=&quot;Q-NOV&quot;)ts = pd.Series(np.random.randn(len(prng)), prng)ts.index = (prng.asfreq(&quot;M&quot;, &quot;e&quot;)+1).asfreq(&quot;H&quot;, &quot;s&quot;) + 9ts.head() 1990-03-01 09:00 -0.982376 1990-06-01 09:00 1.155590 1990-09-01 09:00 -0.304843 1990-12-01 09:00 0.494812 1991-03-01 09:00 0.667193 Freq: H, dtype: float64 카테고리pandas는 DataFrame 123df = pd.DataFrame(&#123; &quot;id&quot;: [1, 2, 3, 4, 5, 6], &quot;raw_grade&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;e&quot;]&#125;) 원시 성적을 범주 형 데이터 유형으로 변환합니다. 123df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)df[&quot;grade&quot;] 0 a 1 b 2 b 3 a 4 a 5 e Name: grade, dtype: category Categories (3, object): [&#39;a&#39;, &#39;b&#39;, &#39;e&#39;] 범주 이름을 보다 의미있는 이름으로 바꿉니다. 1df[&quot;grade&quot;].cat.categories = [&quot;very good&quot;, &quot;good&quot;, &quot;very bad&quot;] 범주를 재정렬하고 동시에 누락 된 범주를 추가합니다.(기본적으로 Series.cat() 새로운 방법을 반환하는 방법 Series) 12345df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories( [&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;, &quot;good&quot;, &quot;very good&quot;])df[&quot;grade&quot;] 0 very good 1 good 2 good 3 very good 4 very good 5 very bad Name: grade, dtype: category Categories (5, object): [&#39;very bad&#39;, &#39;bad&#39;, &#39;medium&#39;, &#39;good&#39;, &#39;very good&#39;] 정렬은 어휘 순서가 아닌 범주의 순서에 따라 이루어집니다. 1df.sort_values(by=&quot;grade&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; id raw_grade grade 5 6 e very bad 1 2 b good 2 3 b good 0 1 a very good 3 4 a very good 4 5 a very good 범주형 열로 그룹화하면 빈 범주도 표시됩니다. 1df.groupby(&quot;grade&quot;).size() grade very bad 1 bad 0 medium 0 good 2 very good 3 dtype: int64 플로팅matplotlib API를 참조하기 위해 표준 규칙을 사용합니다. 123import matplotlib.pyplot as pltplt.close(&quot;all&quot;) 12345ts = pd.Series(np.random.randn(1000), index=pd.date_range(&quot;1/1/2000&quot;, periods=1000))ts = ts.cumsum()ts.plot() &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f8300728fd0&gt; DataFrame에서 이 plot()메소드는 레이블이 있는 모든 열을 표시하는데 편리합니다. 1234567891011df = pd.DataFrame( np.random.randn(1000,4), index=ts.index, columns=[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;])df = df.cumsum()plt.figure()df.plot()plt.legend(loc=&#x27;best&#x27;) &lt;matplotlib.legend.Legend at 0x7f82ffc5f6d0&gt; &lt;Figure size 432x288 with 0 Axes&gt; 데이터 입출력CSVcsv파일에 쓰는 중 입니다. 1df.to_csv(&quot;foo.csv&quot;) csv파일에서 읽기 1pd.read_csv(&quot;foo.csv&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; Unnamed: 0 A B C D 0 2000-01-01 -0.946268 0.588085 -1.102185 -2.011696 1 2000-01-02 -0.940977 -0.645644 -2.615629 -2.244082 2 2000-01-03 0.448965 -0.183296 -2.437258 -3.986212 3 2000-01-04 -0.694449 -0.597946 -2.220138 -4.774340 4 2000-01-05 -0.909153 -0.200734 -2.831575 -5.637019 ... ... ... ... ... ... 995 2002-09-22 14.836307 -33.955098 -16.642909 -88.413076 996 2002-09-23 13.802744 -34.419502 -17.817695 -88.713839 997 2002-09-24 14.080196 -34.360305 -19.016304 -89.204070 998 2002-09-25 13.348737 -36.193934 -18.960392 -89.111542 999 2002-09-26 12.908612 -37.943369 -16.614981 -90.344603 1000 rows × 5 columns HDF5HDFStores 읽기 및 쓰기 HDF5 스토어에 쓰기 1df.to_hdf(&quot;foo.h5&quot;, &quot;df&quot;) HDF5스토어에서 읽기 1pd.read_hdf(&quot;foo.h5&quot;, &quot;df&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; A B C D 2000-01-01 -0.946268 0.588085 -1.102185 -2.011696 2000-01-02 -0.940977 -0.645644 -2.615629 -2.244082 2000-01-03 0.448965 -0.183296 -2.437258 -3.986212 2000-01-04 -0.694449 -0.597946 -2.220138 -4.774340 2000-01-05 -0.909153 -0.200734 -2.831575 -5.637019 ... ... ... ... ... 2002-09-22 14.836307 -33.955098 -16.642909 -88.413076 2002-09-23 13.802744 -34.419502 -17.817695 -88.713839 2002-09-24 14.080196 -34.360305 -19.016304 -89.204070 2002-09-25 13.348737 -36.193934 -18.960392 -89.111542 2002-09-26 12.908612 -37.943369 -16.614981 -90.344603 1000 rows × 4 columns 엑셀MS Excel 읽기 및 쓰기 엑셀파일에 쓰기 1df.to_excel(&quot;foo.xlsx&quot;, sheet_name=&quot;Sheet1&quot;) 엑셀 파일에서 읽기. 1pd.read_excel(&quot;foo.xlsx&quot;, &quot;Sheet1&quot;, index_col=None, na_values=[&quot;NA&quot;]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th &#123; vertical-align: top; &#125; .dataframe thead th &#123; text-align: right; &#125; Unnamed: 0 A B C D 0 2000-01-01 -0.946268 0.588085 -1.102185 -2.011696 1 2000-01-02 -0.940977 -0.645644 -2.615629 -2.244082 2 2000-01-03 0.448965 -0.183296 -2.437258 -3.986212 3 2000-01-04 -0.694449 -0.597946 -2.220138 -4.774340 4 2000-01-05 -0.909153 -0.200734 -2.831575 -5.637019 ... ... ... ... ... ... 995 2002-09-22 14.836307 -33.955098 -16.642909 -88.413076 996 2002-09-23 13.802744 -34.419502 -17.817695 -88.713839 997 2002-09-24 14.080196 -34.360305 -19.016304 -89.204070 998 2002-09-25 13.348737 -36.193934 -18.960392 -89.111542 999 2002-09-26 12.908612 -37.943369 -16.614981 -90.344603 1000 rows × 5 columns 고차작업을 수행하려는 경우 다음과 같은 예외가 표시될 수 있습니다. 12if pd.Series([False, True, False]): print(&quot;I was true&quot;) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-140-5c782b38cd2f&gt; in &lt;module&gt;() ----&gt; 1 if pd.Series([False, True, False]): 2 print(&quot;I was true&quot;) /usr/local/lib/python3.7/dist-packages/pandas/core/generic.py in __nonzero__(self) 1328 def __nonzero__(self): 1329 raise ValueError( -&gt; 1330 f&quot;The truth value of a &#123;type(self).__name__&#125; is ambiguous. &quot; 1331 &quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot; 1332 ) ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://kjm94.github.io/tags/python/"}]},{"title":"시각화","slug":"시각화","date":"2021-04-07T14:02:07.000Z","updated":"2021-04-07T14:11:46.489Z","comments":true,"path":"2021/04/07/시각화/","link":"","permalink":"https://kjm94.github.io/2021/04/07/%EC%8B%9C%EA%B0%81%ED%99%94/","excerpt":"","text":"Matplotlib데이터 불러오기 123456789101112131415import matplotlib.pyplot as pltdates = [ &#x27;2021-01-01&#x27;, &#x27;2021-01-02&#x27;, &#x27;2021-01-03&#x27;, &#x27;2021-01-04&#x27;, &#x27;2021-01-05&#x27;, &#x27;2021-01-06&#x27;, &#x27;2021-01-07&#x27;, &#x27;2021-01-08&#x27;, &#x27;2021-01-09&#x27;, &#x27;2021-01-10&#x27;]min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig,axes = plt.subplots(nrows=1, ncols=1, figsize = (10,6))axes.plot(dates, min_temperature, label = &#x27;Min Temperature&#x27;)axes.plot(dates, max_temperature, label = &#x27;Max Temperature&#x27;)axes.legend()plt.show() 12print(fig)print(axes) Figure(720x432) AxesSubplot(0.125,0.125;0.775x0.755) 선 그래프pyplot API123import fix_yahoo_finance as yfdata = yf.download(&#x27;AAPL&#x27;, &#x27;2019-08-01&#x27;, &#x27;2020-08-01&#x27;)data.info() [*********************100%***********************] 1 of 1 downloaded &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; DatetimeIndex: 253 entries, 2019-08-01 to 2020-07-31 Data columns (total 6 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Open 253 non-null float64 1 High 253 non-null float64 2 Low 253 non-null float64 3 Close 253 non-null float64 4 Adj Close 253 non-null float64 5 Volume 253 non-null int64 dtypes: float64(5), int64(1) memory usage: 13.8 KB 12ts = data[&#x27;Open&#x27;]print(ts.head()) Date 2019-08-01 53.474998 2019-08-02 51.382500 2019-08-05 49.497501 2019-08-06 49.077499 2019-08-07 48.852501 Name: Open, dtype: float64 123456789101112import fix_yahoo_finance as yfimport matplotlib.pyplot as pltdata = yf.download(&#x27;AAPL&#x27;, &#x27;2019-08-01&#x27;,&#x27;2020-08-01&#x27;)ts = data[&#x27;Open&#x27;]plt.figure(figsize=(10,6))plt.plot(ts)plt.legend(labels=[&#x27;Price&#x27;], loc=&#x27;best&#x27;)plt.title(&#x27;Stock Market fluctuation of AAPL&#x27;)plt.xlabel(&#x27;Date&#x27;)plt.ylabel(&#x27;Stock Market Open Price&#x27;)plt.show() [*********************100%***********************] 1 of 1 downloaded 객체지향 API123456789101112from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvasfrom matplotlib.figure import Figurefig = Figure()import numpy as npnp.random.seed(6)x = np.random.randn(20000)ax = fig.add_subplot(111)ax.hist(x, 100)ax.set_title(&#x27;Artist Layer Histogram&#x27;)fig.savefig(&#x27;Matplotlib_histogram.png&#x27;) 1234567891011121314import fix_yahoo_finance as yfimport matplotlib.pyplot as pltdata = yf.download(&#x27;AAPL&#x27;, &#x27;2019-08-01&#x27;, &#x27;2020-08-01&#x27;)ts = data[&#x27;Open&#x27;]fig = plt.figure(figsize=(10,6)) # 직접 Figure 객체 생성ax = fig.subplots() # 직접 axes를 생성ax.plot(ts) # 생성된 axes에 대한 plot() 멤버 직접 호출ax.set_title(&#x27;Stock Market fluctuation of AAPL&#x27;)ax.legend(labels=[&#x27;Price&#x27;], loc=&#x27;best&#x27;)ax.set_xlabel(&#x27;Data&#x27;)ax.set_ylabel(&#x27;Stock Market Open Price&#x27;)plt.show() [*********************100%***********************] 1 of 1 downloaded 막대그래프12345678910111213141516171819import matplotlib.pyplot as pltimport numpy as npimport calendarmonth_list = [1,2,3,4,5,6,7,8,9,10,11,12]sold_list = [300,400,550,900,600,960,900,910,800,700,550,450]fig, ax = plt.subplots(figsize=(10,6))plot = ax.bar(month_list, sold_list)ax.set_xticks(month_list)ax.set_xticklabels(calendar.month_name[1:13], rotation=90)for rect in plot: print(rect) height = rect.get_height() ax.text(rect.get_x() + rect.get_width()/2., 1.002*height, &#x27;%d&#x27;% int(height), ha=&#x27;center&#x27;, va=&#x27;bottom&#x27;)plt.show() Rectangle(xy=(0.6, 0), width=0.8, height=300, angle=0) Rectangle(xy=(1.6, 0), width=0.8, height=400, angle=0) Rectangle(xy=(2.6, 0), width=0.8, height=550, angle=0) Rectangle(xy=(3.6, 0), width=0.8, height=900, angle=0) Rectangle(xy=(4.6, 0), width=0.8, height=600, angle=0) Rectangle(xy=(5.6, 0), width=0.8, height=960, angle=0) Rectangle(xy=(6.6, 0), width=0.8, height=900, angle=0) Rectangle(xy=(7.6, 0), width=0.8, height=910, angle=0) Rectangle(xy=(8.6, 0), width=0.8, height=800, angle=0) Rectangle(xy=(9.6, 0), width=0.8, height=700, angle=0) Rectangle(xy=(10.6, 0), width=0.8, height=550, angle=0) Rectangle(xy=(11.6, 0), width=0.8, height=450, angle=0) 산점도 그래프1234567891011121314import matplotlib.pyplot as pltimport seaborn as snstips = sns.load_dataset(&quot;tips&quot;)x = tips[&#x27;total_bill&#x27;]y = tips[&#x27;tip&#x27;]fig, ax = plt.subplots(figsize=(10,6))ax.scatter(x, y)ax.set_xlabel(&#x27;Total Bill&#x27;)ax.set_ylabel(&#x27;Tip&#x27;)ax.set_title(&#x27;Tip ~ Total Bill&#x27;)fig.show() 1label, data = tips.groupby(&#x27;sex&#x27;) 12345678910111213tips[&#x27;sex_color&#x27;] = tips[&#x27;sex&#x27;].map(&#123;&quot;Female&quot; : &quot;#0000FF&quot;, &quot;Male&quot; : &quot;#00FF00&quot;&#125;)fig, ax = plt.subplots(figsize=(10,6))for label, data in tips.groupby(&#x27;sex&#x27;): ax.scatter(data[&#x27;total_bill&#x27;], data[&#x27;tip&#x27;], label=label, color=data[&#x27;sex_color&#x27;], alpha=0.5) ax.set_xlabel(&#x27;Total Bill&#x27;) ax.set_ylabel(&#x27;Tip&#x27;) ax.set_title(&#x27;Tip ~ Total Bill by Gender&#x27;)ax.legend()fig.show() 히스토그램12345678910111213141516171819import matplotlib.pyplot as pltimport numpy as npimport seaborn as snstitanic = sns.load_dataset(&#x27;titanic&#x27;)age = titanic[&#x27;age&#x27;]nbins = 21fig, ax = plt.subplots(figsize=(10, 6))#histogramax.hist(age, bins= nbins)ax.set_xlabel(&quot;Age&quot;)ax.set_ylabel(&quot;Frequency&quot;)ax.set_title(&quot;Distribution of Aae in Titanic&quot;)#vlineax.axvline(x = age.mean(), linewidth = 2, color = &#x27;b&#x27;)fig.show() 박스플롯12345678910111213import matplotlib.pyplot as pltimport seaborn as snsiris = sns.load_dataset(&#x27;iris&#x27;)data = [iris[iris[&#x27;species&#x27;]==&#x27;setosa&#x27;][&#x27;petal_width&#x27;], iris[iris[&#x27;species&#x27;]==&#x27;versicolor&#x27;][&#x27;petal_width&#x27;], iris[iris[&#x27;species&#x27;]==&#x27;virginica&#x27;][&#x27;petal_width&#x27;],]fig, ax = plt.subplots(figsize=(10,6))ax.boxplot(data, labels=[&#x27;setosa&#x27;, &#x27;versicolor&#x27;, &#x27;virginica&#x27;])fig.show() 히트맵123456789101112131415import matplotlib.pyplot as pltimport numpy as npimport seaborn as snsflights = sns.load_dataset(&#x27;flights&#x27;)flights = flights.pivot(&quot;month&quot;,&quot;year&quot;,&quot;passengers&quot;)print(flights)fig, ax = plt.subplots(figsize=(12,6))im = ax.imshow(flights, cmap = &#x27;YlGnBu&#x27;)ax.set_xticklabels(flights.columns, rotation = 20)ax.set_yticklabels(flights.index, rotation = 10)fig.colorbar(im)fig.show() year 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 month Jan 112 115 145 171 196 204 242 284 315 340 360 417 Feb 118 126 150 180 196 188 233 277 301 318 342 391 Mar 132 141 178 193 236 235 267 317 356 362 406 419 Apr 129 135 163 181 235 227 269 313 348 348 396 461 May 121 125 172 183 229 234 270 318 355 363 420 472 Jun 135 149 178 218 243 264 315 374 422 435 472 535 Jul 148 170 199 230 264 302 364 413 465 491 548 622 Aug 148 170 199 242 272 293 347 405 467 505 559 606 Sep 136 158 184 209 237 259 312 355 404 404 463 508 Oct 119 133 162 191 211 229 274 306 347 359 407 461 Nov 104 114 146 172 180 203 237 271 305 310 362 390 Dec 118 140 166 194 201 229 278 306 336 337 405 432","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://kjm94.github.io/tags/python/"}]},{"title":"List and tuple","slug":"List-and-tuple","date":"2021-04-06T03:19:17.000Z","updated":"2021-04-07T12:41:36.733Z","comments":true,"path":"2021/04/06/List-and-tuple/","link":"","permalink":"https://kjm94.github.io/2021/04/06/List-and-tuple/","excerpt":"","text":"리스트와 튜플12list = [1, 2, &quot;a&quot;, 3, 4] # 리스트의 형태tuple = (5, 6, &quot;b&quot;, 7, 8) # 튜플의 형태 두 타입 모두 요소의 순서를 관리하지만 기술적으로 유일한 차이점이 있다. 리스트는 가변(mutable)성 튜플은 불변(immutable)성 즉 튜플은 append, insert, expend, remove, del, pop 등의 함수를 통해 기존의 자료를 변경할 수 없음. 리스트는 튜플에 비해 더 많은 공간을 저장해둔다. 리스트는 딕셔너리의 key값으로 사용할 수 없지만 튜플은 가능하다. 다루는 자료가 다른 길이의 데이터를 갖는다면 리스트를 사용한다. 함수형 프로그래밍에서는 코드가 어려워 질 수 있는 부작용을 피하기 위해불변 데이터를 사용하는 것을 권장한다.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://kjm94.github.io/tags/python/"}]},{"title":"컴퓨터 공학 입문 수료증","slug":"컴퓨터-공학-입문-수료증","date":"2021-04-04T13:30:59.000Z","updated":"2021-04-06T13:42:21.673Z","comments":true,"path":"2021/04/04/컴퓨터-공학-입문-수료증/","link":"","permalink":"https://kjm94.github.io/2021/04/04/%EC%BB%B4%ED%93%A8%ED%84%B0-%EA%B3%B5%ED%95%99-%EC%9E%85%EB%AC%B8-%EC%88%98%EB%A3%8C%EC%A6%9D/","excerpt":"","text":"1단계 수료증https://pabi.smartlearn.io/certificates/92e0f41b4f52411faa9a6d9223a5e2eb 2단계 수료증https://pabi.smartlearn.io/certificates/f62ff5faca5c4557a5c0f502c9184b9e","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://kjm94.github.io/tags/C/"}]},{"title":"R 데이터 정리, 시각화 연습 코드","slug":"R-데이터-정리-시각화-연습-코드","date":"2021-04-03T04:23:08.000Z","updated":"2021-04-03T04:23:24.637Z","comments":true,"path":"2021/04/03/R-데이터-정리-시각화-연습-코드/","link":"","permalink":"https://kjm94.github.io/2021/04/03/R-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%95%EB%A6%AC-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%97%B0%EC%8A%B5-%EC%BD%94%EB%93%9C/","excerpt":"","text":"참고 사이트http://www.sthda.com/english/wiki/descriptive-statistics-and-graphics","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"Data Swap","slug":"Data-Swap","date":"2021-04-01T00:08:34.000Z","updated":"2021-04-06T13:42:21.670Z","comments":true,"path":"2021/04/01/Data-Swap/","link":"","permalink":"https://kjm94.github.io/2021/04/01/Data-Swap/","excerpt":"","text":"데이터 변환 각 데이터 타입별로 변수에 저장된 값을 서로 바꾼다. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;template&lt;typename SwapData&gt;void Swap(SwapData&amp; num1, SwapData&amp; num2)&#123; SwapData temp = num1; num1 = num2; num2 = temp;&#125;int main()&#123; int num1 = 2, num2 = 4; double num3 = 1.14, num4 = 3.57; cout &lt;&lt; &quot;스왑이전, num1 : &quot; &lt;&lt; num1 &lt;&lt; &quot;, num2 : &quot; &lt;&lt; num2 &lt;&lt; endl; Swap(num1, num2); cout &lt;&lt; &quot;스왑이후, num1 : &quot; &lt;&lt; num1 &lt;&lt; &quot;, num2 : &quot; &lt;&lt; num2 &lt;&lt; endl; cout &lt;&lt; &quot;스왑이전, num3 : &quot; &lt;&lt; num3 &lt;&lt; &quot;, num4 : &quot; &lt;&lt; num4 &lt;&lt; endl; Swap(num3, num4); cout &lt;&lt; &quot;스왑이후, num3 : &quot; &lt;&lt; num3 &lt;&lt; &quot;, num4 : &quot; &lt;&lt; num4 &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://kjm94.github.io/tags/C/"}]},{"title":"미등록 패키지 연동","slug":"미등록-패패키지-연동","date":"2021-03-31T05:03:59.000Z","updated":"2021-04-03T04:13:59.491Z","comments":true,"path":"2021/03/31/미등록-패패키지-연동/","link":"","permalink":"https://kjm94.github.io/2021/03/31/%EB%AF%B8%EB%93%B1%EB%A1%9D-%ED%8C%A8%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%97%B0%EB%8F%99/","excerpt":"","text":"12345678910111213141516171819if(!require(remotes))&#123; install.packages(&#x27;remotes&#x27;)&#125; # remotes 가져오는 함수remotes::install_github(&quot;profandyfield/discovr&quot;)# 설치되지 않는 경우.libPaths() # 위치확인 함수로 확인remotes::install_github(&quot;profandyfield/discovr&quot;, lib = &quot;N:/Documents/R/win-library/3.5&quot;) # 본인 위치 입력library(discovr) # 라이브러리 등록learnr::run_tutorial(&quot;name_of_tutorial&quot;, package = &quot;discovr&quot;) # 해당 패키지의 튜토리얼 등록learnr::run_tutorial(&quot;discovr_02&quot;, package = &quot;discovr&quot;) # 튜토리얼 페이지 실행","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"데이터 사이언스를 위한 통계학입문 수료증","slug":"데이터-사이언스를-위한-통e¼계학입문-수료증","date":"2021-03-31T00:09:02.000Z","updated":"2021-04-03T04:13:59.488Z","comments":true,"path":"2021/03/31/데이터-사이언스를-위한-통e¼계학입문-수료증/","link":"","permalink":"https://kjm94.github.io/2021/03/31/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%82%AC%EC%9D%B4%EC%96%B8%EC%8A%A4%EB%A5%BC-%EC%9C%84%ED%95%9C-%ED%86%B5e%C2%BC%EA%B3%84%ED%95%99%EC%9E%85%EB%AC%B8-%EC%88%98%EB%A3%8C%EC%A6%9D/","excerpt":"","text":"1단계 수료증https://pabi.smartlearn.io/certificates/45cd0c85f0364738a196e75de7f1b456 2단계 수료증https://pabi.smartlearn.io/certificates/41b3e499fd7745b3bcbc62b8592793e5","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"overriding","slug":"overriding","date":"2021-03-28T05:34:16.000Z","updated":"2021-04-03T04:13:59.487Z","comments":true,"path":"2021/03/28/overriding/","link":"","permalink":"https://kjm94.github.io/2021/03/28/overriding/","excerpt":"","text":"함수 오버라이딩 개와 고양이 클래스를 따로 생성하여 동물 클래스에 상속받기 울음소리를 오버라이딩 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;class Animal&#123;public: void cry() &#123; cout &lt;&lt; &quot;짖는소리&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal&#123;public: void cry() &#123; cout &lt;&lt; &quot;개짖는소리 왈왈&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal&#123;public: void cry() &#123; cout &lt;&lt; &quot;고양이 짖는소리 냐옹&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Dog d; Cat c; d.cry(); c.cry(); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://kjm94.github.io/tags/C/"}]},{"title":"Random Game 2","slug":"Random-Game-2","date":"2021-03-27T10:56:19.000Z","updated":"2021-04-03T04:13:59.483Z","comments":true,"path":"2021/03/27/Random-Game-2/","link":"","permalink":"https://kjm94.github.io/2021/03/27/Random-Game-2/","excerpt":"","text":"동전 던지기 게임랜덤 함수 활용 1을 입력하면 앞면과 뒷면 중 랜덤하게 출력 0을 입력하면 종료 외 숫자 입력 시 예외출력 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;random&gt;using namespace std;int main()&#123; int Coin; random_device rd; mt19937 gen(rd()); uniform_int_distribution&lt;int&gt; dis(0, 1); string com_out; while (1) &#123; int com = dis(gen); cout &lt;&lt; &quot;동전던지기 시작(1) 종료(0)&quot; &lt;&lt; endl; cin &gt;&gt; Coin; if (Coin == 0) &#123; cout &lt;&lt; &quot;종료&quot; &lt;&lt; endl; break; &#125; else if (Coin == 1) &#123; // 시작 if (com == 0) &#123; cout &lt;&lt; &quot;뒷면&quot; &lt;&lt; endl; &#125; else if (com == 1) &#123; cout &lt;&lt; &quot;앞면&quot; &lt;&lt; endl; &#125; &#125; else &#123; cout &lt;&lt; &quot;0과 1의 숫자로 다시 시도하세요.&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://kjm94.github.io/tags/C/"}]},{"title":"datacamp","slug":"datacamp","date":"2021-03-26T12:58:34.000Z","updated":"2021-03-26T13:00:07.814Z","comments":true,"path":"2021/03/26/datacamp/","link":"","permalink":"https://kjm94.github.io/2021/03/26/datacamp/","excerpt":"","text":"##R 코딩 연습 R 코딩이 어렵다고 생각하여 연습하기 위해 datacamp 링크 저장 https://www.datacamp.com/users/sign_in?redirect=https%3A%2F%2Flearn.datacamp.com%2Fcourses","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"","slug":"marprac","date":"2021-03-26T12:53:13.614Z","updated":"2021-03-26T12:53:13.615Z","comments":true,"path":"2021/03/26/marprac/","link":"","permalink":"https://kjm94.github.io/2021/03/26/marprac/","excerpt":"","text":"House prices: Lasso, XGBoost, and a detailed EDA h1 {font-size: 34px;} h1.title {font-size: 38px;} h2 {font-size: 30px;} h3 {font-size: 24px;} h4 {font-size: 18px;} h5 {font-size: 16px;} h6 {font-size: 12px;} code {color: inherit; background-color: rgba(0, 0, 0, 0.04);} pre:not([class]) { background-color: white } code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;} ul.task-list{list-style: none;} code{white-space: pre;} if (window.hljs) { hljs.configure({languages: []}); hljs.initHighlightingOnLoad(); if (document.readyState && document.readyState === \"complete\") { window.setTimeout(function() { hljs.initHighlighting(); }, 0); } } .main-container { max-width: 940px; margin-left: auto; margin-right: auto; } img { max-width:100%; } .tabbed-pane { padding-top: 12px; } .html-widget { margin-bottom: 20px; } button.code-folding-btn:focus { outline: none; } summary { display: list-item; } pre code { padding: 0; } .tabset-dropdown > .nav-tabs { display: inline-table; max-height: 500px; min-height: 44px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; } .tabset-dropdown > .nav-tabs > li.active:before { content: \"\"; font-family: 'Glyphicons Halflings'; display: inline-block; padding: 10px; border-right: 1px solid #ddd; } .tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before { content: \"\"; border: none; } .tabset-dropdown > .nav-tabs.nav-tabs-open:before { content: \"\"; font-family: 'Glyphicons Halflings'; display: inline-block; padding: 10px; border-right: 1px solid #ddd; } .tabset-dropdown > .nav-tabs > li.active { display: block; } .tabset-dropdown > .nav-tabs > li > a, .tabset-dropdown > .nav-tabs > li > a:focus, .tabset-dropdown > .nav-tabs > li > a:hover { border: none; display: inline-block; border-radius: 4px; background-color: transparent; } .tabset-dropdown > .nav-tabs.nav-tabs-open > li { display: block; float: none; } .tabset-dropdown > .nav-tabs > li { display: none; } House prices: Lasso, XGBoost, and a detailed EDA Kwon jung min 1 Loading and Exploring Data #요약 저는 데이터 세트를 잘 이해하는 데 집중하면서이 대회를 시작했습니다. EDA는 상세하며 많은 시각화가 포함되어 있습니다. 이 버전에는 모델링도 포함됩니다. Lasso 회귀는 교차 검증 RMSE 점수가 0.1121 일 때 가장 잘 수행됩니다. 변수들 사이에 많은 다중 공선 성이 있다는 사실을 감안할 때 이것은 예상되었습니다. Lasso는 예상대로 모델에서 사용 가능한 많은 변수를 선택하지 않습니다. XGBoost 모델은 교차 검증 RMSE가 0.1162로 매우 잘 수행됩니다. *이 두 알고리즘은 매우 다르기 때문에 평균 예측은 예측을 향상시킬 수 있습니다. Lasso 교차 검증 RMSE가 XGBoost의 CV 점수보다 낫기 때문에 Lasso 결과에 두 배의 가중치를 부여하기로 결정했습니다. #Introduction Kaggle은 이 경쟁을 다음과 같이 설명합니다. follows: 주택 구입자에게 꿈의 집을 설명해달라고 요청하면 지하 천장 높이나 동서 철도와의 근접성으로 시작하지 않을 것입니다. 그러나이 놀이터 대회의 데이터 세트는 침실 수나 흰둥이 울타리보다 가격 협상에 훨씬 더 많은 영향을 미친다는 것을 증명합니다. 아이오와 주 에임스에있는 주거용 주택의 거의 모든 측면을 설명하는 79 개의 설명 변수가있는이 경쟁에서는 각 주택의 최종 가격을 예측해야합니다. 1 Loading and Exploring Data ##Loading libraries required and reading the data into R 기본 R 외에 사용되는 R 패키지를로드합니다. # 메세지와 경고를 출력하지 않는다. (반대 : TRUE) library(knitr) # 동적 보고서 생성 엔진 참고 URL : https://en.wikipedia.org/wiki/Knitr library(ggplot2) # 데이터 시각화 패키지 library(plyr) # 데이터 분할, 적용, 조합의 세단계로 데이터를 처리하는 함수 제공 (배열, 데이터 프레임, 리스트) 참고 URL : https://data-make.tistory.com/59 library(dplyr) # 데이터 전처리, 가공 library(corrplot) # 상관행렬과 신뢰구간의 그래프, 행렬의 재정렬 알고리즘 포함 패키지 참고 URL : https://rpubs.com/cardiomoon/27080 library(caret) # 복잡한 회귀와 분류 문제에 대한 모형 훈련과 조절과정을 간소화 하는 함수 참고 URL : http://kocw-n.xcache.kinxcdn.com/data/document/2017/chungbuk/najonghwa/8.pdf library(gridExtra) # 차트 분할 출력 library(scales) # 시각적 맵핑 library(Rmisc) # 데이터 분석 및 유틸리티에 유용한 함수 모음 library(ggrepel) # 레이블 정리 참고 URL : https://kuduz.tistory.com/1111 library(randomForest) # 랜덤으로 만들어 나온 결과를 투표방식으로 예측하는 알고리즘 참고 URL : https://hongsamm.tistory.com/20 library(psych) # 기술통계량을 제공하는 함수 중 하나 참고 URL : https://dr-hkim.github.io/R-301-Descriptive-Statistics/ library(xgboost) # 병렬처리 최적화 패키지 상관행렬 : 확률론과 통계학에서 두 변수간에 어떤 선형적 관계를 갖고 있는 지를 분석하는 방법 신뢰구간 : 표본평균 분포 병렬처리 : 동시에 많은 계산을 하는 연산의 방법 참고URL : https://ko.wikipedia.org/wiki/%EB%B3%91%EB%A0%AC_%EC%BB%B4%ED%93%A8%ED%8C%85 아래에서는 csv를 데이터 프레임으로 R로 읽고 있습니다. train &lt;- read.csv(&quot;train.csv&quot;, stringsAsFactors = F) # 데이터를 R로 불러오지만 메모리에 저장되는 것은 아님 stringsAsFactors : 데이터를 불러올 때, 데이터에 숫자 외의 데이터로 인한 오류 방지 ##데이터 크기 및 구조 train 데이터 세트는 문자 및 정수 변수로 구성됩니다. 대부분의 문자 변수는 실제로 (순서적인) 요인이지만 대부분의 경우 정리 및 / 또는 기능 엔지니어링이 먼저 필요하기 때문에 문자열로 R로 읽기로 선택했습니다. 총 81 개의 열 / 변수가 있으며 마지막 열은 반응 변수 (SalePrice)입니다. 아래에서는 변수를 간략하게 보여주고 있습니다. 그들 모두는 문서 전체에서 더 자세히 논의됩니다. #ID를 제거하지만 테스트 ID를 벡터에 유지합니다. 제출 파일을 작성하는 데 필요합니다. train$Id &lt;- NULL all &lt;- rbind(train) # rbind : 데이터 결합 dim(all) # 데이터프레임 의 길이 관측, 행과 열의 갯수를 출력 ## [1] 1460 80 ID가 없으면 데이터 프레임은 79 개의 예측 변수와 응답 변수 SalePrice로 구성됩니다. #Exploring some of the most important variables ##반응 변수; SalePrice 보시다시피 판매 가격이 올바르게 왜곡되어 있습니다. 이것은 매우 비싼 집을 살 수있는 사람이 거의 없기 때문에 예상되었습니다. 이를 염두에두고 모델링 전에 조치를 취하겠습니다. ggplot(data=all[!is.na(all$SalePrice),], aes(x=SalePrice)) + geom_histogram(fill=&quot;blue&quot;, binwidth = 10000) + scale_x_continuous(breaks= seq(0, 800000, by=100000), labels = comma) binwidth : 연속형 변수를 일정한 구간으로 나누어 빈도수를 구한 후 막대 그래프로 표현 summary(all$SalePrice) # 기술통계 함수 참고 URL : http://blog.naver.com/PostView.nhn?blogId=rickman2&amp;logNo=221451645853&amp;categoryNo=40&amp;parentCategoryNo=0 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 34900 129975 163000 180921 214000 755000 ##가장 중요한 숫자 예측 변수 문자 변수를 사용하려면 작업이 필요합니다. 데이터 세트에 대한 느낌을 얻기 위해 먼저 SalePrice와 높은 상관 관계가있는 숫자 변수를 확인하기로 결정했습니다. ###SalePrice와의 상관 관계 전체적으로 SalePrice와 최소 0.5의 상관 관계가있는 10 개의 숫자 변수가 있습니다. 이러한 모든 상관 관계는 긍정적입니다. numericVars &lt;- which(sapply(all, is.numeric)) #인덱스 벡터 숫자 형 변수 numericVarNames &lt;- names(numericVars) #나중에 사용하기 위해 names 벡터 저장 cat(&#39;There are&#39;, length(numericVars), &#39;numeric variables&#39;) ## There are 37 numeric variables # which : 특정 값의 위치를 찾는 함수 찾고자 하는 값의 위치를 반환 all_numVar &lt;- all[, numericVars] cor_numVar &lt;- cor(all_numVar, use=&quot;pairwise.complete.obs&quot;) #모든 숫자 변수의 상관 관계 #SalePrice와의 감소하는 상관 관계에 따라 정렬 cor_sorted &lt;- as.matrix(sort(cor_numVar[,&#39;SalePrice&#39;], decreasing = TRUE)) #높은 corelations 만 선택 CorHigh &lt;- names(which(apply(cor_sorted, 1, function(x) abs(x)&gt;0.5))) cor_numVar &lt;- cor_numVar[CorHigh, CorHigh] corrplot.mixed(cor_numVar, tl.col=&quot;black&quot;, tl.pos = &quot;lt&quot;) 이 섹션의 나머지 부분에서는 SalePrice와 SalePrice와 가장 높은 상관 관계를 가진 두 예측 변수 간의 관계를 시각화합니다. 전반적인 품질 및 ’고급’생활 공간 (이것은 지하실에없는 집의 비율입니다. link). 또한 다중 공선 성이 문제라는 것이 분명해집니다. 예를 들어, GarageCars와 GarageArea 간의 상관 관계는 매우 높고 (0.89) 둘 다 SalePrice와 유사한 (높은) 상관 관계를가집니다. SalePrice와의 상관 관계가 0.5보다 높은 나머지 6 개의 변수는 다음과 같습니다.: -TotalBsmtSF: 지하 총 평방 피트 -1stFlrSF: 1 층 평방 피트 -FullBath: 욕실 포함 등급 이상의 방 -TotRmsAbvGrd: 등급 이상의 총 방 (욕실은 포함되지 않음) -YearBuilt: 원래 건설 날짜 -YearRemodAdd: 리모델링 날짜 (개조 또는 추가가없는 경우 건설 날짜와 동일) ###전반적인 품질 전체 품질은 수치 변수 (0.79) 중 SalePrice와 가장 높은 상관 관계를 나타냅니다. 집의 전체 재료와 마감을 1 (매우 나쁨)에서 10 (매우 우수)까지 등급으로 평가합니다. ggplot(data=all[!is.na(all$SalePrice),], aes(x=factor(OverallQual), y=SalePrice))+ geom_boxplot(col=&#39;blue&#39;) + labs(x=&#39;Overall Quality&#39;) + scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) 양의 상관 관계는 확실히 존재하며 약간 상승 곡선 인 것 같습니다. 특이 치에 관해서는 극단적 인 값이 보이지 않습니다. 나중에 이상치로 빼낼 후보가 있으면 4 급 고가 집 인 것 같다. ###지상 (지상) 거실 공간 (평방 피트) SalesPrice와 두 번째로 높은 상관 관계가있는 숫자 변수는 Grade Living Area입니다. 이것은 많은 의미가 있습니다. 큰 집은 일반적으로 더 비쌉니다. ggplot(data=all[!is.na(all$SalePrice),], aes(x=GrLivArea, y=SalePrice))+ geom_point(col=&#39;blue&#39;) + geom_smooth(method = &quot;lm&quot;, se=FALSE, color=&quot;black&quot;, aes(group=1)) + scale_y_continuous(breaks= seq(0, 800000, by=100000), labels = comma) + geom_text_repel(aes(label = ifelse(all$GrLivArea[!is.na(all$SalePrice)]&gt;4500, rownames(all), &#39;&#39;))) ## Warning: Use of `all$GrLivArea` is discouraged. Use `GrLivArea` instead. ## Warning: Use of `all$SalePrice` is discouraged. Use `SalePrice` instead. ## `geom_smooth()` using formula &#39;y ~ x&#39; rownames : 행 이름을 바꾸는 함수 특히 거실이 넓고 SalePrices가 낮은 두 주택은 이상치처럼 보입니다 (주택 524 및 1299, 그래프의 레이블 참조). 이상 값을 가져 오는 것은 위험 할 수 있으므로 아직 제거하지 않겠습니다. 예를 들어, 전반적인 품질에서 낮은 점수는 낮은 가격을 설명 할 수 있습니다. 그러나 아래에서 볼 수 있듯이 이 두 주택은 실제로 전체 품질에서 최대 점수를 얻습니다. 따라서 저는 1299 호와 524 호를 이상 값으로 제거 할 주요 후보로 염두에 두겠습니다. all[c(524, 1299), c(&#39;SalePrice&#39;, &#39;GrLivArea&#39;, &#39;OverallQual&#39;)] ## SalePrice GrLivArea OverallQual ## 524 184750 4676 10 ## 1299 160000 5642 10 #누락 된 데이터, 레이블 인코딩 및 변수 분해 ##데이터의 완전성 우선, 어떤 변수에 결 측값이 있는지 확인하고 싶습니다. NAcol &lt;- which(colSums(is.na(all)) &gt; 0) sort(colSums(sapply(all[NAcol], is.na)), decreasing = TRUE) ## PoolQC MiscFeature Alley Fence FireplaceQu LotFrontage ## 1453 1406 1369 1179 690 259 ## GarageType GarageYrBlt GarageFinish GarageQual GarageCond BsmtExposure ## 81 81 81 81 81 38 ## BsmtFinType2 BsmtQual BsmtCond BsmtFinType1 MasVnrType MasVnrArea ## 38 37 37 37 8 8 ## Electrical ## 1 sort : 숫자 자체 정렬 decreasing : 내림차순 cat(&#39;There are&#39;, length(NAcol), &#39;columns with missing values&#39;) ## There are 19 columns with missing values cat : 개행을 하지 않는 출력함수 물론 SalePrice의 1459 NA는 테스트 세트의 크기와 완벽하게 일치합니다. 이는 34 개의 예측 변수에서 NA를 수정해야 함을 의미합니다. ##누락 된 데이터 {.tabset} 대치 이 섹션에서는 결 측값이 포함 된 34 개의 예측 변수를 수정하겠습니다. 나는 그것들을 모두 고칠 때까지 대부분의 NA에서 내려가는 방법을 살펴볼 것입니다. 실제로 다른 변수와 그룹을 형성하는 변수를 우연히 발견하면 그룹으로 다룰 것입니다. 예를 들어, 수영장, 차고 및 지하와 관련된 여러 변수가 있습니다. 문서를 가능한 한 읽기 쉽게 유지하기 위해 knitr에서 제공하는 “Tabs”옵션을 사용하기로 결정했습니다. 각 탭 아래에서 각 변수 (그룹)에 대한 간단한 분석을 찾을 수 있습니다. 모든 섹션을 살펴볼 필요는 없으며 몇 개의 탭만 볼 수도 있습니다. 그렇게한다면, 저는 지하실이나 차고가없는 집을 신중하게 결정했기 때문에 특히 차고와 지하실 섹션이 가치가 있다고 생각합니다. NA가 제거되었는지 확인하는 것 외에도, 명확한 순서가있는 경우 문자 변수를 순서 형 정수로 변환하고 수준이 순서 성이없는 범주 인 경우 요인으로 변환했습니다. 나중에 원-핫 인코딩 (model.matrix 함수 사용)을 사용하여 이러한 요소를 숫자로 변환합니다. ###Pool variables Pool Quality and the PoolArea variable PoolQC는 대부분의 NA가있는 변수입니다. 설명은 다음과 같습니다: PoolQC: Pool quality Ex Excellent Gd Good TA Average/Typical Fa Fair NA No Pool 따라서 NA에 ’No Pool’만 할당하면됩니다. 또한 일반적으로 소수의 주택에만 수영장이 있기 때문에 많은 수의 NA가 의미가 있습니다. all$PoolQC[is.na(all$PoolQC)] &lt;- &#39;None&#39; 값이 서수이므로 이 변수에 레이블을 인코딩 할 수 있다는 것도 분명합니다. 동일한 품질 수준을 사용하는 여러 변수가 있으므로 나중에 다시 사용할 수있는 벡터를 만들 것입니다. Qualities &lt;- c(&#39;None&#39; = 0, &#39;Po&#39; = 1, &#39;Fa&#39; = 2, &#39;TA&#39; = 3, &#39;Gd&#39; = 4, &#39;Ex&#39; = 5) 이제 ’revalue’기능을 사용하여 작업을 수행 할 수 있습니다. all$PoolQC&lt;-as.integer(revalue(all$PoolQC, Qualities)) table(all$PoolQC) ## ## 0 2 4 5 ## 1453 2 3 2 revalue : plyr 패키지 안의 라벨 변경 함수 // add bootstrap table styles to pandoc tables function bootstrapStylePandocTables() { $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed'); } $(document).ready(function () { bootstrapStylePandocTables(); }); $(document).ready(function () { window.buildTabsets(\"TOC\"); }); $(document).ready(function () { $('.tabset-dropdown > .nav-tabs > li').click(function () { $(this).parent().toggleClass('nav-tabs-open'); }); }); (function () { var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = \"https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"; document.getElementsByTagName(\"head\")[0].appendChild(script); })();","categories":[],"tags":[]},{"title":"","slug":"mark1","date":"2021-03-26T12:53:13.606Z","updated":"2021-03-26T12:53:13.607Z","comments":true,"path":"2021/03/26/mark1/","link":"","permalink":"https://kjm94.github.io/2021/03/26/mark1/","excerpt":"","text":"My 1st MarkDown h1 {font-size: 34px;} h1.title {font-size: 38px;} h2 {font-size: 30px;} h3 {font-size: 24px;} h4 {font-size: 18px;} h5 {font-size: 16px;} h6 {font-size: 12px;} code {color: inherit; background-color: rgba(0, 0, 0, 0.04);} pre:not([class]) { background-color: white } code{white-space: pre-wrap;} span.smallcaps{font-variant: small-caps;} span.underline{text-decoration: underline;} div.column{display: inline-block; vertical-align: top; width: 50%;} div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;} ul.task-list{list-style: none;} code{white-space: pre;} if (window.hljs) { hljs.configure({languages: []}); hljs.initHighlightingOnLoad(); if (document.readyState && document.readyState === \"complete\") { window.setTimeout(function() { hljs.initHighlighting(); }, 0); } } .main-container { max-width: 940px; margin-left: auto; margin-right: auto; } img { max-width:100%; } .tabbed-pane { padding-top: 12px; } .html-widget { margin-bottom: 20px; } button.code-folding-btn:focus { outline: none; } summary { display: list-item; } pre code { padding: 0; } .tabset-dropdown > .nav-tabs { display: inline-table; max-height: 500px; min-height: 44px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; } .tabset-dropdown > .nav-tabs > li.active:before { content: \"\"; font-family: 'Glyphicons Halflings'; display: inline-block; padding: 10px; border-right: 1px solid #ddd; } .tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before { content: \"\"; border: none; } .tabset-dropdown > .nav-tabs.nav-tabs-open:before { content: \"\"; font-family: 'Glyphicons Halflings'; display: inline-block; padding: 10px; border-right: 1px solid #ddd; } .tabset-dropdown > .nav-tabs > li.active { display: block; } .tabset-dropdown > .nav-tabs > li > a, .tabset-dropdown > .nav-tabs > li > a:focus, .tabset-dropdown > .nav-tabs > li > a:hover { border: none; display: inline-block; border-radius: 4px; background-color: transparent; } .tabset-dropdown > .nav-tabs.nav-tabs-open > li { display: block; float: none; } .tabset-dropdown > .nav-tabs > li { display: none; } My 1st MarkDown R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. // add bootstrap table styles to pandoc tables function bootstrapStylePandocTables() { $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed'); } $(document).ready(function () { bootstrapStylePandocTables(); }); $(document).ready(function () { window.buildTabsets(\"TOC\"); }); $(document).ready(function () { $('.tabset-dropdown > .nav-tabs > li').click(function () { $(this).parent().toggleClass('nav-tabs-open'); }); }); (function () { var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = \"https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"; document.getElementsByTagName(\"head\")[0].appendChild(script); })();","categories":[],"tags":[]},{"title":"twitter API prac","slug":"twitter-API-prac","date":"2021-03-26T07:21:30.000Z","updated":"2021-03-26T12:53:13.618Z","comments":true,"path":"2021/03/26/twitter-API-prac/","link":"","permalink":"https://kjm94.github.io/2021/03/26/twitter-API-prac/","excerpt":"","text":"트위터 API 인증 https://apps.twitter.com 회원가입 한 뒤 create an app 클릭 후 진행 rtweet 패키지1234# install.packages(&quot;rtweet&quot;)library(rtweet)library(dplyr)library(ggplot2) search Tweets 함수12rstats &lt;- search_tweets(&quot;#테슬라&quot;, n = 1000, include_rts = FALSE) %&gt;% select(name, location, description) 1glimpse(rtats) api 사용자 토큰이 없어서 결과를 올리지 못함.","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"Rshiny setup","slug":"Rshiny-setup","date":"2021-03-25T08:08:18.000Z","updated":"2021-03-26T12:53:13.539Z","comments":true,"path":"2021/03/25/Rshiny-setup/","link":"","permalink":"https://kjm94.github.io/2021/03/25/Rshiny-setup/","excerpt":"","text":"R shiny setup setting12345install.packages(&#x27;rsconnect&#x27;)library(rsconnect)rsconnect::setAccountInfo(name=&#x27;kjm94&#x27;, token=&#x27;14A30ABF3A5B0831FAF5A8FFB145F970&#x27;, secret=&#x27;khn/qL4qNTXeph1BW5ycrB0plemummTXwss47pIA&#x27;)","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"R-ggplot No.1","slug":"R-ggplot","date":"2021-03-24T06:40:25.000Z","updated":"2021-03-26T12:53:13.533Z","comments":true,"path":"2021/03/24/R-ggplot/","link":"","permalink":"https://kjm94.github.io/2021/03/24/R-ggplot/","excerpt":"","text":"눈금 표시 방법123456ggplot(PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() + scale_y_continuous(limits = c(0, 10), # 축 범위 breaks = c(1, 3, 5, 7, 9), # 축의 숫자 지정 labels = c(&quot;1st&quot;, &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;, &quot;nine&quot;)) 범주형 축 항목 순서 변경하기1234ggplot(PlantGrowth, aes(x = group, weight)) + geom_boxplot() + theme_bw() + scale_x_discrete(limits = c(&quot;trt1&quot;, &quot;ctrl&quot;))","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"Random game 1","slug":"Random-game-1","date":"2021-03-23T12:55:42.000Z","updated":"2021-03-23T14:16:35.732Z","comments":true,"path":"2021/03/23/Random-game-1/","link":"","permalink":"https://kjm94.github.io/2021/03/23/Random-game-1/","excerpt":"","text":"가위바위보 1을 입력하면 가위 2를 입력하면 바위 3을 입력하면 보 컴퓨터가 내는 수는 판마다 랜덤(난수) 0을 입력하면 종료 0, 1, 2, 3을 제외한 숫자 입력시 예외처리 게임결과 출력 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;random&gt;using namespace std;string text_temp(int num)&#123; if (num == 1) &#123; return &quot;가위&quot;; &#125; else if (num == 2) &#123; return &quot;바위&quot;; &#125; else &#123; return &quot;보&quot;; &#125;&#125;int main()&#123; int Count = 1; int player; cout &lt;&lt; &quot;가위바위보&quot; &lt;&lt; endl; random_device rd; mt19937 gen(rd()); uniform_int_distribution&lt;int&gt; dis(1, 3); string com_out; while (1) &#123; int com = dis(gen); cout &lt;&lt; &quot;가위(1)바위(2)보(3)종료(0) : &quot;; cin &gt;&gt; player; Count++; if (player == 0) &#123; cout &lt;&lt; &quot;종료&quot; &lt;&lt; endl; break; &#125; else if (player == com) &#123; cout &lt;&lt; &quot;비겼습니다.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;상대(&quot; &lt;&lt; text_temp(com) &lt;&lt; &quot;) : 플레이어(&quot; &lt;&lt; text_temp(player) &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; else if ((player == 1 &amp;&amp; com == 3) || (player == 2 &amp;&amp; com == 1) || (player == 3 &amp;&amp; com == 2)) &#123; cout &lt;&lt; &quot;이겼습니다.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;상대(&quot; &lt;&lt; text_temp(com) &lt;&lt; &quot;) : 플레이어(&quot; &lt;&lt; text_temp(player) &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; else if (player &gt; 3) &#123; cout &lt;&lt; &quot;숫자는 1, 2, 3중에서만 입력해주세요.&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;졌습니다.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;상대(&quot; &lt;&lt; text_temp(com) &lt;&lt; &quot;) : 플레이어(&quot; &lt;&lt; text_temp(player) &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://kjm94.github.io/tags/C/"}]},{"title":"R test1","slug":"R-test1","date":"2021-03-23T07:21:09.000Z","updated":"2021-03-23T12:43:13.174Z","comments":true,"path":"2021/03/23/R-test1/","link":"","permalink":"https://kjm94.github.io/2021/03/23/R-test1/","excerpt":"","text":"패키지 설치 방법 ggplot2와 dplyr 패키지 설치 방법 기재 12install.package(&quot;ggplot2&quot;)install.package(&quot;dplyr&quot;) 패키지 설치 12library(ggplot2)library(dplyr) 라이브러리 연결 액셀 데이터 받아오기12counties &lt;- readxl::read_xlsx(&quot;파일위치/파일이름.xslx&quot;, sheet = 1)glimpse(counties) getwd()로 위치확인 후 진행할 것에 주의glimpse는 현재 데이터를 보여줌 private_work, unemployment를 활용하여 산점도를 작성 region을 기준으로 그룹화 12345ggplot(data = counties, # 데이터 aes(x = private_work, #x축 y = unemployment, #y축 colour = region)) # 색상 = region 4개geom_point() dplyr 함수를 활용하여, 아래 데이터 요약 counties 데이터를 활용합니다. 변수 추출은 region, state, men, women 각 region, state 별 men, wemen 전체 인구수를 구함. 최종 데이터셋 저장 이름은 final_df로 명명 123456789counties %&gt;% select(region, state, county, men, women) %&gt;% # select group_by(region, state) %&gt;% # group_by summarize(total_men = sum(men), #summarize total_women = sum(women)) %&gt;% # head()여기까지 끊는 함수 filter(region == &quot;North Central&quot;) %&gt;% arrange(desc(total_men)) -&gt; final_dfglimpse(final_df) final_df를 기준으로 막대 그래프를 그린다. x축 : state 1개의 region만 선택 12ggplot(final_df, aes(x = state, y = total_men)) +geom_col()","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"image upload","slug":"image-test","date":"2021-03-23T03:39:44.000Z","updated":"2021-03-23T12:43:13.174Z","comments":true,"path":"2021/03/23/image-test/","link":"","permalink":"https://kjm94.github.io/2021/03/23/image-test/","excerpt":"","text":"#이미지 올리기 1![](..&#x2F;image&#x2F;r_markdown&#x2F;pressure-1.png)","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"R aes","slug":"R-menu","date":"2021-03-23T03:19:54.000Z","updated":"2021-03-23T12:43:13.173Z","comments":true,"path":"2021/03/23/R-menu/","link":"","permalink":"https://kjm94.github.io/2021/03/23/R-menu/","excerpt":"","text":"getwd() 위치확인rm(list = ls()) 모두 지우기 12345678910111213141516171819library(ggplot2)ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, colours = Species)) + geom_point(size = 5) + theme_bw()ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, size = Petal.Length, colours = Species)) + geom_point() + theme_bw()ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, colours = Species)) + geom_point(size = 2) + theme_bw() aes(size = Petal.Lengh, colour = Species)전체 옵션 선택 : aes() 밖에서 = 그래프 종류각각의 데이터별로 옵션을 선택aes(안에서 옵션 설정, 변수명)customize –&gt; scale","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"base guide","slug":"abase-guide","date":"2021-03-23T02:57:22.000Z","updated":"2021-03-23T12:43:13.174Z","comments":true,"path":"2021/03/23/abase-guide/","link":"","permalink":"https://kjm94.github.io/2021/03/23/abase-guide/","excerpt":"","text":"깃허브에 소스 업로드1git remote 현재 폴더의 원격 레퍼지토리 확인 명령어 1git remote add 원격저장소이름 https:&#x2F;&#x2F;github.com&#x2F;유저네임&#x2F;레퍼지토리네임.git 깃허브 저장소의 주소로 원격저장소 생성 작업폴더와 깃허브 저장소가 연동됨. 1git push -u origin master push는 업로드 명령어 수정 후 업데이트123git add 파일명git commit -m &quot;msg&quot;git push commit은 수정한 내용에 대한 코멘터리 소스 내려 받기깃허브 원격 저장소의 Clone or download에서 주소를 복사 복사를 시킬 폴더 생성 IDE로 폴더 오픈 후, 터미널에서 클론 명령어 1git clone https:&#x2F;&#x2F;github.com&#x2F;유저네임&#x2F;원격저장소이름.git 내려받아진 폴더로 터미널 이동 1cd 폴더 깃 로그 명령어를 통해 이전 작업내용 확인가능 1git log 이전 반영된 파일 받아오기 1git pull 원격저장소명 브랜치명","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kjm94.github.io/tags/git/"}]},{"title":"git clone","slug":"clone","date":"2021-03-23T02:52:27.000Z","updated":"2021-03-23T12:43:13.174Z","comments":true,"path":"2021/03/23/clone/","link":"","permalink":"https://kjm94.github.io/2021/03/23/clone/","excerpt":"","text":"1git clone --depth 1 https:&#x2F;&#x2F;github.com&#x2F;chinsun9&#x2F;refactor-2019T1.git commit history 없이 clone 하는 방법–depth 옵션–depth 1 -&gt; 가장 마지막 상태 클론","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://kjm94.github.io/tags/git/"}]},{"title":"R-DAY1","slug":"R-DAY1","date":"2021-03-22T05:28:16.000Z","updated":"2021-03-23T12:43:13.173Z","comments":true,"path":"2021/03/22/R-DAY1/","link":"","permalink":"https://kjm94.github.io/2021/03/22/R-DAY1/","excerpt":"","text":"12345# Factor 범주형 변수# 컴퓨터 &lt;- 숫자로 인식# 문자 숫자 논리형 순으로 저장# ordered = TRUE# levels = c(&quot;정렬&quot;) 12345678910111213141516171819202122232425262728# 1. 사람과 관련된 데이터# - 고객 데이터 (CRM)# 2. 기계와 관련된 데이터# - 제조공정과 관련된 데이터# install.packages(&quot;패키지&quot;) 패키지 설치# 1단계 : 패키지 불러오기install.packages(&quot;ggplot2&quot;)library(ggplot2)# 2단계 : 데이터 불러오기data(&quot;iris&quot;)# 3단계 : 데이터 확인str(iris)# 4단계 : 데이터 가공 하기 (시각화)# 5단계 : 시각화ggplot(data = iris, mapping = aes(x = Petal.Length, y = Petal.Width)) + geom_point() + geom_smooth(method=&quot;loess&quot;, se=F) + #xlim(c(0, 0.1)) + #ylim(c(0, 500000)) + labs(subtitle=&quot;Area Vs Population&quot;, y=&quot;Population&quot;, x=&quot;Area&quot;, title=&quot;Scatterplot&quot;, caption = &quot;Source: midwest&quot;)","categories":[],"tags":[{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"}]},{"title":"Adoring","slug":"Adoring","date":"2021-03-22T02:26:06.000Z","updated":"2021-03-23T12:43:13.173Z","comments":true,"path":"2021/03/22/Adoring/","link":"","permalink":"https://kjm94.github.io/2021/03/22/Adoring/","excerpt":"","text":"123456789#include &lt;iostream&gt;int main()&#123; std::cout&lt;&lt;&quot;첫번째 정수 입력 : &quot;; std::cin&gt;&gt; inum1; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://kjm94.github.io/tags/C/"}]},{"title":"practice","slug":"practice","date":"2021-03-22T02:21:48.000Z","updated":"2021-03-23T12:43:13.178Z","comments":true,"path":"2021/03/22/practice/","link":"","permalink":"https://kjm94.github.io/2021/03/22/practice/","excerpt":"","text":"1234a = 1b = 2c = a + bprint(c) 패키지 설치1","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://kjm94.github.io/tags/python/"}]},{"title":"temp","slug":"temp","date":"2021-03-22T02:08:46.000Z","updated":"2021-03-23T12:43:13.178Z","comments":true,"path":"2021/03/22/temp/","link":"","permalink":"https://kjm94.github.io/2021/03/22/temp/","excerpt":"","text":"R 설치 R을 설치한다. URL: https://www.r-project.org/소스코드 작성 R 소스코드를 작성합니다.1234a &lt;- 1b &lt;- 2c &lt;- a + bprint(c)","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://kjm94.github.io/tags/python/"},{"name":"C","slug":"C","permalink":"https://kjm94.github.io/tags/C/"},{"name":"R","slug":"R","permalink":"https://kjm94.github.io/tags/R/"},{"name":"C++","slug":"C","permalink":"https://kjm94.github.io/tags/C/"},{"name":"git","slug":"git","permalink":"https://kjm94.github.io/tags/git/"}]}